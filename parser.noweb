@ A formal grammar consists of a set of terminal symbols, a set of non-terminal symbols, an initial {\it start symbol}, and a series of rules or {\it productions} 
which map strings of symbols, either terminal or non-terminal, to other strings. The language generated by the grammar consists of all strings of terminals 
that can be reached via repeated application of productions, beginning with the start symbol.

Context-free grammars have productions which consist of a single non-terminal on their left hand side. Most (all?) computer languages are context-free grammars.

The following grammar defines the language of arithmetic operations on the numbers 1, 2, 3

<<*>>=
(defparameter arith-grammar
    (list
     'START '(EXP)
     'exp '(term)
     'term '(term + term)
     'term '(factor)
     'term '(factor * factor)
     'factor '(1)
     'factor '(2)
     'factor '(3)
     'factor '([ exp ])
))
@ I now construct a parser which can be used to determine whether a particular sequence of tokens belongs to a given grammar. This parser will be an LL(1) parser,
which means it ..... - write definition here. 

I need to determine whether a token can expand into the null symbol. It is easier to determine the entire set of nullable symbols. The algorithm for this is
is simply that a token is nullable if it expands directly into the null symbol, or else it has an expansion into nullable tokens. This is via an algorithm 
that loops until some accumulator no longer increases in size. We use this algorithm frequently, so is worth getting out of the way.
<<*>>=
(defun limit-of-fn (fn x &key (test #'equal))
	(let ((x1 (fn x)))
		(if (funcall test x1 x)
			x1
			(limit-of-fn fn x1))))

(defun nullables (grammar)
  (limit-of-fn (lambda (nullables) 
				 (mapcar #'car 
						 (remove-if-not (dbind-lambda ((token exp)) 
													  (or (member token nullables)
														  (every (lambda (token) (member token nullables)) rhs)))
										grammar)))))
